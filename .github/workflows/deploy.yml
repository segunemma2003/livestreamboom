name: Deploy to AWS Elastic Beanstalk

on:
  push:
    branches:
      - main
      - develop
      - staging

env:
  AWS_REGION: us-east-1
  ECR_REGISTRY: 934155604952.dkr.ecr.us-east-1.amazonaws.com
  ECR_REPOSITORY: livestream-service

jobs:
  deploy-production:
    if: github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    timeout-minutes: 45
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Extract ECR registry and repository from URI
        id: ecr-info
        run: |
          ECR_URI="${{ secrets.ECR_REPOSITORY_URI }}"
          ECR_REGISTRY=$(echo $ECR_URI | cut -d'/' -f1)
          ECR_REPOSITORY=$(echo $ECR_URI | cut -d'/' -f2)

          echo "ECR_REGISTRY=$ECR_REGISTRY" >> $GITHUB_OUTPUT
          echo "ECR_REPOSITORY=$ECR_REPOSITORY" >> $GITHUB_OUTPUT

          echo "ECR Registry: $ECR_REGISTRY"
          echo "ECR Repository: $ECR_REPOSITORY"

      - name: Validate Dockerfile and dependencies
        run: |
          echo "Validating Dockerfile..."
          docker --version
          
          echo "Checking Python requirements..."
          if [ -f requirements.txt ]; then
            echo "Requirements file found"
            head -10 requirements.txt
          else
            echo "ERROR: requirements.txt not found"
            exit 1
          fi
          
          echo "Checking Django settings..."
          if [ -f livestream_project/settings_production.py ]; then
            echo "Production settings found"
          else
            echo "ERROR: Production settings not found"
            exit 1
          fi

      - name: Build Docker image
        env:
          ECR_REGISTRY: ${{ steps.ecr-info.outputs.ECR_REGISTRY }}
          ECR_REPOSITORY: ${{ steps.ecr-info.outputs.ECR_REPOSITORY }}
          IMAGE_TAG: latest
        run: |
          echo "Building image: $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"
          
          # Build with build args for better caching
          docker build \
            --build-arg BUILDKIT_INLINE_CACHE=1 \
            --cache-from $ECR_REGISTRY/$ECR_REPOSITORY:latest \
            -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG \
            -t $ECR_REGISTRY/$ECR_REPOSITORY:prod-${GITHUB_SHA::7} \
            .
          
          echo "Image built successfully"
          docker images | grep $ECR_REPOSITORY

      - name: Test Docker image locally
        env:
          ECR_REGISTRY: ${{ steps.ecr-info.outputs.ECR_REGISTRY }}
          ECR_REPOSITORY: ${{ steps.ecr-info.outputs.ECR_REPOSITORY }}
          IMAGE_TAG: latest
        run: |
          echo "Testing Docker image locally..."
          
          # Start container in background with proper environment variables
          CONTAINER_ID=$(docker run -d \
            -p 8000:8000 \
            -e DEBUG=False \
            -e DJANGO_SETTINGS_MODULE=livestream_project.settings_production \
            -e SECRET_KEY=test-key-for-build-$(date +%s) \
            -e ALLOWED_HOSTS="localhost,127.0.0.1,*" \
            -e PYTHONPATH=/app \
            --health-cmd="curl -f http://localhost:8000/health/ || exit 1" \
            --health-interval=10s \
            --health-timeout=5s \
            --health-retries=3 \
            --health-start-period=30s \
            $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG)
          
          echo "Container ID: $CONTAINER_ID"
          
          # Function to check container status
          check_container_status() {
            local status=$(docker inspect --format='{{.State.Status}}' $CONTAINER_ID 2>/dev/null)
            echo $status
          }
          
          # Function to check container health
          check_container_health() {
            local health=$(docker inspect --format='{{.State.Health.Status}}' $CONTAINER_ID 2>/dev/null)
            echo $health
          }
          
          # Wait for container to start and become healthy
          echo "Waiting for container to start..."
          MAX_WAIT=120  # 2 minutes
          WAIT_TIME=0
          
          while [ $WAIT_TIME -lt $MAX_WAIT ]; do
            STATUS=$(check_container_status)
            HEALTH=$(check_container_health)
            
            echo "Time: ${WAIT_TIME}s - Status: $STATUS, Health: $HEALTH"
            
            if [ "$STATUS" = "running" ]; then
              if [ "$HEALTH" = "healthy" ] || [ "$HEALTH" = "" ]; then
                echo "‚úÖ Container is running and healthy!"
                break
              fi
            elif [ "$STATUS" = "exited" ]; then
              echo "‚ùå Container exited unexpectedly"
              echo "Container logs:"
              docker logs $CONTAINER_ID
              exit 1
            fi
            
            sleep 5
            WAIT_TIME=$((WAIT_TIME + 5))
          done
          
          # Final status check
          FINAL_STATUS=$(check_container_status)
          if [ "$FINAL_STATUS" != "running" ]; then
            echo "‚ùå Container failed to start properly"
            echo "Final status: $FINAL_STATUS"
            echo "Container logs:"
            docker logs $CONTAINER_ID
            exit 1
          fi
          
          # Test health endpoint directly
          echo "Testing health endpoint..."
          HEALTH_SUCCESS=false
          
          for i in {1..12}; do  # Try for 1 minute
            echo "Health check attempt $i/12..."
            
            if curl -f -s --max-time 10 http://localhost:8000/health/; then
              echo "‚úÖ Health check passed!"
              HEALTH_SUCCESS=true
              break
            fi
            
            # Show more detailed curl output for debugging
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:8000/health/ 2>/dev/null || echo "000")
            echo "HTTP status code: $HTTP_CODE"
            
            if [ $i -eq 6 ]; then
              echo "Health check taking longer than expected, showing container logs:"
              docker logs --tail=20 $CONTAINER_ID
            fi
            
            sleep 5
          done
          
          if [ "$HEALTH_SUCCESS" = false ]; then
            echo "‚ùå Health check failed after all attempts"
            echo "Final container logs:"
            docker logs $CONTAINER_ID
            
            echo "Container inspect:"
            docker inspect $CONTAINER_ID
            
            echo "Attempting to connect to container directly:"
            docker exec $CONTAINER_ID curl -v http://localhost:8000/health/ || true
            
            exit 1
          fi
          
          # Test additional endpoints if health passes
          echo "Testing additional endpoints..."
          
          # Test if Django admin is accessible (should return 302 or 200)
          ADMIN_CODE=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:8000/admin/ 2>/dev/null || echo "000")
          echo "Admin endpoint status: $ADMIN_CODE"
          
          # Test API endpoint
          API_CODE=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:8000/api/ 2>/dev/null || echo "000")
          echo "API endpoint status: $API_CODE"
          
          echo "‚úÖ Docker container test completed successfully!"
          
          # Cleanup
          echo "Stopping and removing container..."
          docker stop $CONTAINER_ID
          docker rm $CONTAINER_ID

      - name: Push Docker image to ECR
        env:
          ECR_REGISTRY: ${{ steps.ecr-info.outputs.ECR_REGISTRY }}
          ECR_REPOSITORY: ${{ steps.ecr-info.outputs.ECR_REPOSITORY }}
          IMAGE_TAG: latest
        run: |
          echo "Pushing images to ECR..."
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:prod-${GITHUB_SHA::7}
          
          echo "Verifying image in ECR..."
          aws ecr describe-images \
            --repository-name $ECR_REPOSITORY \
            --image-ids imageTag=$IMAGE_TAG \
            --query 'imageDetails[0].imageSizeInBytes' \
            --output text

      - name: Update Dockerrun.aws.json
        env:
          ECR_REGISTRY: ${{ steps.ecr-info.outputs.ECR_REGISTRY }}
          ECR_REPOSITORY: ${{ steps.ecr-info.outputs.ECR_REPOSITORY }}
          IMAGE_TAG: latest
        run: |
          echo "Updating Dockerrun.aws.json..."
          # Update the image reference in Dockerrun.aws.json
          sed -i "s|\"image\": \".*\"|\"image\": \"$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG\"|g" Dockerrun.aws.json
          
          echo "Validating Dockerrun.aws.json..."
          python -m json.tool Dockerrun.aws.json > /dev/null
          
          echo "Updated Dockerrun.aws.json:"
          cat Dockerrun.aws.json

      - name: Create deployment package
        run: |
          echo "Creating deployment package..."
          
          # Create deployment directory
          mkdir -p deploy-temp
          
          # Copy required files
          cp Dockerrun.aws.json deploy-temp/
          cp -r .ebextensions deploy-temp/ 2>/dev/null || echo "No .ebextensions directory found"
          
          # Create the zip file
          cd deploy-temp
          zip -r ../deploy.zip .
          cd ..
          
          echo "Deployment package created:"
          ls -la deploy.zip
          unzip -l deploy.zip

      - name: Ensure S3 bucket exists and upload deployment package
        env:
          S3_BUCKET: ${{ secrets.S3_BUCKET }}
        run: |
          echo "Checking S3 bucket: $S3_BUCKET"
          
          # Check if bucket exists, create if not
          if ! aws s3api head-bucket --bucket "$S3_BUCKET" 2>/dev/null; then
            echo "Creating S3 bucket: $S3_BUCKET"
            if [ "$AWS_REGION" = "us-east-1" ]; then
              aws s3api create-bucket --bucket "$S3_BUCKET" --region "$AWS_REGION"
            else
              aws s3api create-bucket \
                --bucket "$S3_BUCKET" \
                --region "$AWS_REGION" \
                --create-bucket-configuration LocationConstraint="$AWS_REGION"
            fi
            
            # Wait for bucket to be ready
            aws s3api wait bucket-exists --bucket "$S3_BUCKET"
          fi
          
          # Upload deployment package
          S3_KEY="deployments/prod-${GITHUB_SHA::7}-$(date +%s).zip"
          aws s3 cp deploy.zip "s3://$S3_BUCKET/$S3_KEY"
          
          echo "S3_KEY=$S3_KEY" >> $GITHUB_ENV
          echo "Deployment package uploaded to: s3://$S3_BUCKET/$S3_KEY"

      - name: Deploy to Elastic Beanstalk with enhanced error handling
        env:
          S3_BUCKET: ${{ secrets.S3_BUCKET }}
          APP_NAME: ${{ secrets.EB_APPLICATION_NAME }}
          ENV_NAME: ${{ secrets.EB_ENVIRONMENT_NAME }}
        run: |
          VERSION_LABEL="prod-${GITHUB_SHA::7}-$(date +%s)"
          echo "Creating application version: $VERSION_LABEL"
          echo "App: $APP_NAME, Environment: $ENV_NAME"

          # Get current environment status
          CURRENT_STATUS=$(aws elasticbeanstalk describe-environments \
            --environment-names "$ENV_NAME" \
            --query 'Environments[0].Status' \
            --output text)
          echo "Current environment status: $CURRENT_STATUS"

          # Check if environment is in a deployable state
          if [[ "$CURRENT_STATUS" != "Ready" && "$CURRENT_STATUS" != "Warning" ]]; then
            echo "Environment is not ready for deployment (Status: $CURRENT_STATUS)"
            echo "Waiting for environment to become ready..."
            aws elasticbeanstalk wait environment-updated --environment-names "$ENV_NAME"
          fi

          # Create application version
          aws elasticbeanstalk create-application-version \
            --application-name "$APP_NAME" \
            --version-label "$VERSION_LABEL" \
            --description "Production deployment from commit ${GITHUB_SHA::7}" \
            --source-bundle S3Bucket="$S3_BUCKET",S3Key="$S3_KEY"

          # Deploy with retry logic
          MAX_ATTEMPTS=3
          ATTEMPT=1
          DEPLOYMENT_SUCCESS=false

          while [ $ATTEMPT -le $MAX_ATTEMPTS ] && [ "$DEPLOYMENT_SUCCESS" = false ]; do
            echo "=== Deployment attempt $ATTEMPT/$MAX_ATTEMPTS ==="
            
            # Start deployment
            if aws elasticbeanstalk update-environment \
              --environment-name "$ENV_NAME" \
              --version-label "$VERSION_LABEL"; then
              
              echo "Deployment command submitted successfully"
              
              # Wait for deployment with timeout
              echo "Waiting for deployment to complete (timeout: 30 minutes)..."
              
              if timeout 1800 aws elasticbeanstalk wait environment-updated \
                --environment-names "$ENV_NAME" \
                --cli-read-timeout 0 \
                --cli-connect-timeout 60; then
                
                # Check final status
                FINAL_STATUS=$(aws elasticbeanstalk describe-environments \
                  --environment-names "$ENV_NAME" \
                  --query 'Environments[0].Status' \
                  --output text)
                
                FINAL_HEALTH=$(aws elasticbeanstalk describe-environments \
                  --environment-names "$ENV_NAME" \
                  --query 'Environments[0].Health' \
                  --output text)
                
                echo "Final Status: $FINAL_STATUS, Health: $FINAL_HEALTH"
                
                if [[ "$FINAL_STATUS" == "Ready" ]] && [[ "$FINAL_HEALTH" =~ ^(Green|Yellow)$ ]]; then
                  echo "‚úÖ Deployment completed successfully!"
                  DEPLOYMENT_SUCCESS=true
                  break
                else
                  echo "‚ùå Deployment completed but environment is not healthy"
                fi
              else
                echo "‚ùå Deployment timed out or failed"
              fi
            else
              echo "‚ùå Failed to submit deployment command"
            fi
            
            if [ "$DEPLOYMENT_SUCCESS" = false ]; then
              if [ $ATTEMPT -lt $MAX_ATTEMPTS ]; then
                echo "Deployment attempt $ATTEMPT failed, waiting before retry..."
                sleep 60
              fi
              ATTEMPT=$((ATTEMPT + 1))
            fi
          done

          if [ "$DEPLOYMENT_SUCCESS" = false ]; then
            echo "üí• All deployment attempts failed"
            
            # Get recent events for debugging
            echo "Recent environment events:"
            aws elasticbeanstalk describe-events \
              --environment-name "$ENV_NAME" \
              --max-items 10 \
              --query 'Events[*].[EventDate,Severity,Message]' \
              --output table
            
            exit 1
          fi

      - name: Post-deployment health verification
        env:
          ENV_NAME: ${{ secrets.EB_ENVIRONMENT_NAME }}
        run: |
          echo "=== Post-deployment health verification ==="
          
          # Get environment URL
          ENV_URL=$(aws elasticbeanstalk describe-environments \
            --environment-names "$ENV_NAME" \
            --query 'Environments[0].CNAME' \
            --output text)
          
          if [ "$ENV_URL" != "None" ] && [ ! -z "$ENV_URL" ]; then
            echo "Environment URL: http://$ENV_URL"
            
            # Test health endpoint with retries
            echo "Testing health endpoint..."
            HEALTH_SUCCESS=false
            
            for i in {1..10}; do
              echo "Health check attempt $i/10..."
              
              if curl -f -s --max-time 30 "http://$ENV_URL/health/" > /dev/null; then
                echo "‚úÖ Health check passed!"
                HEALTH_SUCCESS=true
                break
              fi
              
              echo "Health check failed, waiting 15 seconds..."
              sleep 15
            done
            
            if [ "$HEALTH_SUCCESS" = false ]; then
              echo "‚ùå Health check failed after 10 attempts"
              echo "This may indicate application startup issues"
              
              # Try to get a response anyway for debugging
              echo "Attempting to get health response for debugging:"
              curl -v "http://$ENV_URL/health/" || true
              
              exit 1
            fi
            
            # Test main API endpoint
            echo "Testing main API endpoint..."
            if curl -f -s --max-time 30 "http://$ENV_URL/api/v1/livestream/test-connection/" > /dev/null; then
              echo "‚úÖ API endpoint test passed!"
            else
              echo "‚ö†Ô∏è  API endpoint test failed (may be expected if requires authentication)"
            fi
            
          else
            echo "‚ö†Ô∏è  Could not retrieve environment URL"
          fi

      - name: Cleanup old application versions
        env:
          APP_NAME: ${{ secrets.EB_APPLICATION_NAME }}
        run: |
          echo "Cleaning up old application versions..."
          
          # Keep only the latest 10 versions
          aws elasticbeanstalk describe-application-versions \
            --application-name "$APP_NAME" \
            --query 'ApplicationVersions[10:].VersionLabel' \
            --output text | tr '\t' '\n' | while read version; do
            if [ ! -z "$version" ]; then
              echo "Deleting old version: $version"
              aws elasticbeanstalk delete-application-version \
                --application-name "$APP_NAME" \
                --version-label "$version" \
                --delete-source-bundle
            fi
          done

      - name: Notify deployment status
        if: always()
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            echo "üéâ Production deployment completed successfully!"
            echo "Commit: ${GITHUB_SHA::7}"
            echo "Branch: ${{ github.ref_name }}"
          else
            echo "üí• Production deployment failed!"
            echo "Check the logs above for details"
          fi

  deploy-staging:
    if: github.ref == 'refs/heads/develop' || github.ref == 'refs/heads/staging'
    runs-on: ubuntu-latest
    timeout-minutes: 30
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Extract ECR registry and repository from URI
        id: ecr-info
        run: |
          ECR_URI="${{ secrets.ECR_REPOSITORY_URI }}"
          ECR_REGISTRY=$(echo $ECR_URI | cut -d'/' -f1)
          ECR_REPOSITORY=$(echo $ECR_URI | cut -d'/' -f2)

          echo "ECR_REGISTRY=$ECR_REGISTRY" >> $GITHUB_OUTPUT
          echo "ECR_REPOSITORY=$ECR_REPOSITORY" >> $GITHUB_OUTPUT

      - name: Build and push staging Docker image
        env:
          ECR_REGISTRY: ${{ steps.ecr-info.outputs.ECR_REGISTRY }}
          ECR_REPOSITORY: ${{ steps.ecr-info.outputs.ECR_REPOSITORY }}
          IMAGE_TAG: staging
        run: |
          echo "Building staging image: $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"
          
          docker build \
            --build-arg BUILDKIT_INLINE_CACHE=1 \
            -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG \
            -t $ECR_REGISTRY/$ECR_REPOSITORY:staging-${GITHUB_SHA::7} \
            .
          
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:staging-${GITHUB_SHA::7}

      - name: Update Dockerrun.aws.json for staging
        env:
          ECR_REGISTRY: ${{ steps.ecr-info.outputs.ECR_REGISTRY }}
          ECR_REPOSITORY: ${{ steps.ecr-info.outputs.ECR_REPOSITORY }}
          IMAGE_TAG: staging
        run: |
          sed -i "s|\"image\": \".*\"|\"image\": \"$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG\"|g" Dockerrun.aws.json
          python -m json.tool Dockerrun.aws.json > /dev/null

      - name: Create and upload staging deployment package
        env:
          S3_BUCKET: ${{ secrets.S3_BUCKET_STAGING }}
        run: |
          mkdir -p deploy-temp
          cp Dockerrun.aws.json deploy-temp/
          cp -r .ebextensions deploy-temp/ 2>/dev/null || echo "No .ebextensions directory"
          cd deploy-temp && zip -r ../deploy.zip . && cd ..
          
          # Ensure staging bucket exists
          if ! aws s3api head-bucket --bucket "$S3_BUCKET" 2>/dev/null; then
            if [ "$AWS_REGION" = "us-east-1" ]; then
              aws s3api create-bucket --bucket "$S3_BUCKET" --region "$AWS_REGION"
            else
              aws s3api create-bucket \
                --bucket "$S3_BUCKET" \
                --region "$AWS_REGION" \
                --create-bucket-configuration LocationConstraint="$AWS_REGION"
            fi
          fi
          
          S3_KEY="deployments/staging-${GITHUB_SHA::7}-$(date +%s).zip"
          aws s3 cp deploy.zip "s3://$S3_BUCKET/$S3_KEY"
          echo "S3_KEY=$S3_KEY" >> $GITHUB_ENV

      - name: Deploy to Elastic Beanstalk Staging
        env:
          S3_BUCKET: ${{ secrets.S3_BUCKET_STAGING }}
          APP_NAME: ${{ secrets.EB_APPLICATION_NAME }}
          ENV_NAME: ${{ secrets.EB_STAGING_ENVIRONMENT_NAME }}
        run: |
          VERSION_LABEL="staging-${GITHUB_SHA::7}-$(date +%s)"
          
          # Create application version
          aws elasticbeanstalk create-application-version \
            --application-name "$APP_NAME" \
            --version-label "$VERSION_LABEL" \
            --description "Staging deployment from commit ${GITHUB_SHA::7}" \
            --source-bundle S3Bucket="$S3_BUCKET",S3Key="$S3_KEY"

          # Deploy to staging
          aws elasticbeanstalk update-environment \
            --environment-name "$ENV_NAME" \
            --version-label "$VERSION_LABEL"

          # Wait for deployment
          echo "Waiting for staging deployment to complete..."
          aws elasticbeanstalk wait environment-updated --environment-names "$ENV_NAME"

          # Check final status
          FINAL_STATUS=$(aws elasticbeanstalk describe-environments \
            --environment-names "$ENV_NAME" \
            --query 'Environments[0].Status' \
            --output text)
          
          echo "Staging deployment completed with status: $FINAL_STATUS"

      - name: Test staging deployment
        if: success()
        env:
          ENV_NAME: ${{ secrets.EB_STAGING_ENVIRONMENT_NAME }}
        run: |
          ENV_URL=$(aws elasticbeanstalk describe-environments \
            --environment-names "$ENV_NAME" \
            --query 'Environments[0].CNAME' \
            --output text)
          
          if [ "$ENV_URL" != "None" ] && [ ! -z "$ENV_URL" ]; then
            echo "Testing staging environment: http://$ENV_URL"
            
            for i in {1..5}; do
              if curl -f "http://$ENV_URL/health/"; then
                echo "‚úÖ Staging health check passed!"
                break
              fi
              echo "Staging health check attempt $i failed, retrying..."
              sleep 10
            done
          fi

  notify-completion:
    needs: [deploy-production, deploy-staging]
    if: always()
    runs-on: ubuntu-latest
    
    steps:
      - name: Deployment Summary
        run: |
          echo "=== Deployment Summary ==="
          echo "Commit: ${{ github.sha }}"
          echo "Branch: ${{ github.ref_name }}"
          echo "Timestamp: $(date)"
          
          if [ "${{ needs.deploy-production.result }}" == "success" ]; then
            echo "‚úÖ Production deployment: SUCCESS"
          elif [ "${{ needs.deploy-production.result }}" == "skipped" ]; then
            echo "‚è≠Ô∏è  Production deployment: SKIPPED"
          else
            echo "‚ùå Production deployment: FAILED"
          fi
          
          if [ "${{ needs.deploy-staging.result }}" == "success" ]; then
            echo "‚úÖ Staging deployment: SUCCESS"
          elif [ "${{ needs.deploy-staging.result }}" == "skipped" ]; then
            echo "‚è≠Ô∏è  Staging deployment: SKIPPED"
          else
            echo "‚ùå Staging deployment: FAILED"
          fi
